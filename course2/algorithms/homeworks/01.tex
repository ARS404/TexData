\subsection{Домашка первая}

\i Для начала посчитаем значение префикс-функции для нашей строки $s$ и запишем их в массив $P$. Далее посмотирм на некоторое значение $P[i]$, заметим, что все префиксы 
встречаются длины меньше, чем $P[i]$ встречаются в нейшей строке в качестве подстроки соответствующей длины, начинающейся с позиции $i - P[i]$, что верно,
так как мы знаем, что строка с $i - P[i]$ по $i$ в точности совпадает с префиксом длины $P[i]$. При этом ни одно совпадение, начинающееся в рассматриваемой 
позиции, не может иметь длины больше, чем $P[i]$ (что очевидно), а значит мы посчитали все вхождение, начинающиеся в позиции $i - P[i]$, также, пробежавшись по всем $i > 0$ 
мы, очевидно, посчитаем все вхождения, а значит найдём ответ на задачу и получим $\sum_{i=1}^{s.size()-1} P[i]$. При этом за линию мы посчитали значения
префикс-функции, и за линию их просуммировали, получили решение за $O(n)$, а это то, что мы хотели.

\i Будем строить строку итеративно. Для начала скажем, что первая буква равна некоторой букве $a$ (ну а кто нам запретит), после этого мы знаем, что на всех
индексах $i$, таких, что $Z[i] > 0$ стоит буква $a$ (где $Z$ --- массив со значениями $z$-функции). Далее на очередной итерации будем брать первую позицию
$i$, которой ещё не назначена буква. Мы уже знаем, что $Z[i] = 0$, иначе бы там стояла буква $a$, посмотрим, существует ли $j$ такое, что $j + Z[j] >= i \And 
j < i$, то есть мы ищем такую позицию, что префикс, посчитаный в ней накрывает $i$-тую позицию. Если он существует, то мы однозначно выставляем символ $i$, 
так как все предыдущие уже посчитаны, и $i$-тый совпадает с одним из них. Если этого не случилось, то мы понимаем, что не существует никакой подстроки, 
которая совпадает с префиксом собираемой строки ($s$), и при этом содержит сомвол с индекосм $i$, тогда нет никакой проблемы засунуть туда уникальный символ.
При этом на каждой итерации мы проставляем хотя бы один символ, и ни на один из них не смотрим дважды, а значит весь алгоритм работает за линию.
\begin{remark*}
    Тут я считаю, что алфавит мы выибраем сами (так как обратного не сказано в условии), а значит уникальный символ найдётся всегда.
\end{remark*}

\i Для начала посчитаем $z$-функцию для нашей строки $s$, запишем её в массив $Z$. Далее посмотрим, может ли суффикс, начинающийся с символа $i$. мы знаем, что
подстрока с $i$ по $i + Z[i]$ в точности совпадает с префиксом $s$, хамечательно, значит, если следующего символа нет (конец строки), то суффикс, начинающийся 
с этом месте точно меньше, иначе посмотрим на следующий символ, он точно отличается от того, который добавляется в префикс (иначе значение $z$-функции было бы 
больше), а значит суффикс и префикс можно однозначно сравнить, это победа! Таким образом, мы посчитали $z$-функцию за линию, и дали ответ про каждый из суффиксов
за константу, перебрав все за линию, получили $O(n)$, как и хотели!

\i Эту задачу мы разобрали на семинаре, подойдёт <<пробаффанный бор>> из алгоритма Ахо Корасик. 

\i Очень хочется начать с постройки автомата как в 4 задаче, так что так и поступим. Заметим, что в получившемся дереве нельзя ходить по вершинам, по котором через 
префиксные ссылки можно добратся до терминальной (возможно что за 0 ходов). При этом, очевидно, все остальные вершины посещать можно. Тогда можно просто $DFS$-ом 
обойти дерево (обновляя глубину, если можно её увеличить). ТОгда у нас получится нужная асимптотика, победа. 
