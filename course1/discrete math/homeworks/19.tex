\subsubsection{Девятнадцатое ДЗ}


\i По сути, нам достаточно реализовать тернарный поиск, который работает за $O(\log_{\frac{3}{2}}(n))$. В самом начале узнаем значение чсел $a_1$ и $a_n$. На очередной итерации будем делить отрезок, на котором работаем ($[l_0, r_0]$) на 3 примерно равные части (то есть такие, что их длина отличается не более, чем на 1) с концами в целых точках (стартуем с отрезка $[1, n]$). В 2 новых границах (левая "--- $l$, правая "--- $r$) будем узнавать значения чисел в массиве, далее рассмотрим несколько случаев того, какими оказались знаки:
\begin{enumerate}
    \item $a_l = a_r$, тогда можно сказать, что на отрезке $[l, r]$ есть локальный максимум, а по условию задачи он единственный, так что будем рассматривать отрезок $[l, r]$.
    \item $a_l < a_r$, тогда понятно, что на отрезке $[l, r_0]$ находится максимальный элемент, так что будем рассматривать его.
    \item $a_l > a_r$. Этот случай аналогичен предыдущему, только надо рассмотреть отрезок $[l_0, r]$.
\end{enumerate}
Таким образом, за одну итерацию мы сокращаем отрезок, на котором работаем не меньше, чем в полтора раза, затратив на это не больше 2 операций, таким образом, наш алгоритм работает за $O(\log_{\frac{3}{2}}(n))$, а так как логарифмы с разными основаниями отличаются домножением на константу, то это тоже самое, что $O(\log(n))$. Что и требовалось доказать.

\i Если $n$ чётно, то достаточно разбить все монеты на пары и сравнить монеты в каждой паре. Из условия очевидно, что ровно один раз мы получим неравенство и так найдём фальшивую монету. Если же монет нечётное число, то отложим одну из них и повторим действия для чётного $n$. Тогда возможно, что мы получим одно неравенство и так найдём фальшивую монету (так как она ровно одна, и только с ней может получится неравенство), или же во всех взвешиваняих мы получим знаки равенства, что гарантирует, что все монеты, которые мывзвешивали настоящие, тогда методом исключения получим, что фальшивая монета это та, которую мы отложили. Таким образом, мы гарантированно находим фальшивую монету не более, чем за $\floor{\frac{n}{2}}$ взвешиваний. Что и требовалось доказать.

\i Предположим, что у мы провели некоторые всзвешивания, все из которых показали равенство, и у нас осталось хотя бы 2 монеты, которые мы ни с кем не сравнивали. Тогда мы накак не сможем определить, какая из их фальшивая, поэтому все монеты, кроме, может быть, одной надо сравнить в какой-то другой. Поскольку за одну операцию мы сравниваем 2 монеты, то нам потребуется не меньше, чем $\roof{\frac{n-1}{2}}$ операций, что равно $\floor{\frac{n}{2}}$. Что и требовалось доказать.

\i Рассмотрим разрешающее дерево для произвольного решения этой задачи. Вершинам в нём будут соответствовать вопросы типа <<Верно ли $x_i$>> для произвольного $i$ от 1 до $n$. Предположим, что глубина этого дерева не больше $n-1$. Тогда рассмотрим путь $S$, который соответствует случаю, когда все $x_i$ ложны. Так как его глубина не превосходит $n-1$, то гарантированно найдётся некоторое $x_k$, которое в этом пути не встречается. Тогда, если заменить $x_k$ на истину, то наш путь не изменится, так как не изменятся ответы на вопросы. Таким образом, в первом случае $S$ должен заканчиваться в листе с ложью, а во втором "--- с истиной. Противоречие, а значит глубина разрешающего дерева должна составлять не менее $n$. Осталось только построить разрешающее дерево глубины $n$. Это очень просто, давайте на $i$-том вопросе спрашивать про $x_i$. Если $x_i$ верно, то просто проведём ребро в лист с истиной, если $x_i$ ложно, то проведём ребро в следующий вопрос (если мы задавали вопрос про $x_n$ и получили отрацательный ответ, то проведём ребро в лист в ложью). Очевидно, что такое разрешающее дерево подходит, и оно имеет глубину $n$. Что и требовалось доказать.

\i Давайте каждой операцией делить монеты на 3 примерно равных кучки (то есть таких, что количество монет в них отличается не больше, чем на 1) и сравнивать две из них на весах. Тогда, если весы показывают неравенство, то фальшивая монета гарантированно в той куче, которая лекче, а если равенство, то она, однозначно, в той кучке, котору мы не всзешивали. После этого выберем кучку, в которой лежит фальшивая монета (изначально рассматриваем все $n$ монет) и повторим для неё эту операцию. Таким образом, каждый раз мы уменьшаем количество монет, среди которых лежит фальшивая, примерно в 3 раза, поэтому наш алгоритм работает за $\log_3(n) + O(1)$. Что и требовалось доказать.

\i Давайте доказывать это утверждени по индукции.\\ 
\textit{База}. $n=2$ и $n=3$, очевидно, что в обоих случаях понадобится хотя бы одно взвешивание.\\
\textit{Переход.} Предположим, мы доказали задачу для всех $n < k$, докажм её для $n=k$. Заметим, что всего возможных ответов на первый вопрос у нас ровно 3, тогда по принципу Дерихле в один из ответов приведёт нас к случаю, когда нам надо найти фальшивую монету в не менее, чем $\frac{k}{3}$. В этом случае по предположению индукции нам понадобится хотя бы $\log_3(\frac{k}{3}) + \Omega(1) = \log_3(k) - 1 + \Omega(1)$ вопросов. При этом мы задали ещё и первый вопрос, так что для $n=k$ понадобится не менее, чем $\log_3(n) + \Omega(1)$ вопросов. Что и требовалось доказать.\\
Таким образом, нам гарантированно понадобится хотя бы $\log_3(n) + \Omega(1)$ вопросов.

\i Для начала покажем, как найти самую тяжёлую монету среди произвольных $m$. Для этого на очередной итерации алгоритма будем рассматривать только <<интересные монеты>> (изначально это все $m$ монет). Будм разбивать на пары (если всег монет нечётное число, то одну просто сравним с какой-то из тех, который оказались наибольшими в своей паре), далее в каждой паре выкидывать ту монету, которая лекче и для нового множества переходить к следующей итерации. Очевидно, что в итоге останется самая тяжёлая монета, так как она не может выбыть ни в одном сравнеии. Посчитаем сложность такого алгоритма. Легко понять, что это в точности $\roof{\frac{m}{2}} + \roof{\frac{m}{2^2}} + \ldots + \roof{\frac{m}{2^i}} + \ldots$, что сравнимо с $m + O(1)$.\\
Теперь применим наш алгоритм для начальных $n$ монет и за $m + O(1)$ найдём самую тяжёлую. Теперь осталось понять, как искать вторую по весу монету. Лекго заметить, что любая из остальных монет выбыла в сравнении с самой тяжёлой и может оказаться второй, или же выбыла в стравнении с какой-то другой, в тако случае она точно не может оказаться второй по весу, так как она легче какой-то не самой тяжёлой монеты. Значит нам достаточно искать вторую монету только срди тех, которые мы сравнивали с первой. Всего их было, очевидно $\roof{\log(n)}$, так как на каждой итерации поиска самой тяжёлой количество <<интересных>> монет делилось на 2. А значит применив наш алгоритм повторно для монет, которые сравнивались с первой мы сможем найти самую тяжёлую среди них, а значит (по выше доказанному) вторую по весу среди всех. На это нам понадобится $\log(n) + O(1)$ операций. Таким образом, на поиск первой и второй монеты нам понадобится $n + \log(n) + O(1)$ операций. Что и требовалось доказать.